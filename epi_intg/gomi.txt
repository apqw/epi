/*
template<typename VarTy>
void try_set_with_cast(VarTy& v,const std::string& item){
	v=try_get_with_cast<VarTy>(item);
}

template<typename VarTy,typename K,typename V,typename FirstKey,typename... Keys>
VarTy force_vget(const std::map<K,V>& mp,FirstKey first,Keys... k){
	auto it = get_first_match(mp,first,k...);
	if(it!=mp.end()){
		return try_get_with_cast(it->second);
		//std::cout<<first<<"="<<v<<std::endl;

		//return true;
	}else{
		throw std::logic_error(std::string(first)+" must be specified.");
	}
}
*/


/*
template<typename K,typename V,typename VarTy,typename FirstKey,typename... Keys>
bool force_vdef(const std::map<K,V>& mp,VarTy& v,FirstKey first,Keys... k){
	auto it = get_first_match(mp,first,k...);
	if(it!=mp.end()){
		try_set_with_cast(v,it->second);
		std::cout<<first<<"="<<v<<std::endl;
		return true;

		//return true;
	}else{
		throw std::logic_error(std::string(first)+" must be specified.");
		return false;
	}
}

template<typename K,typename V,typename VarTy>
bool force_vdef(const std::map<K,V>& mp,VarTy& v,const std::vector<K>& kv){
	for(auto& key:kv){
		auto it=mp.find(key);
		if(it!=mp.end()){
			try_set_with_cast(v,it->second);
			std::cout<<key<<"="<<v<<std::endl;
			return true;
		}
	}
}

template<typename K,typename V,typename VarTy,typename DefVarTy,typename FirstKey,typename... Keys>
bool vdef(const std::map<K,V>& mp,VarTy& v,DefVarTy default_value,FirstKey first,Keys... k){
	auto it = get_first_match(mp,first,k...);
	if(it!=mp.end()){
		try_set_with_cast(v,it->second);
		std::cout<<first<<"="<<v<<std::endl;
		return true;
	}else{
		v=default_value;
		std::cout<<first<<"="<<v<<std::endl;
		return false;
	}
}
*/

			/*
			if(!std::is_same<Ty,unsigned int>::value){
				throw std::invalid_argument(std::string("The parameter type is 'unsigned int' but '")+typeid(Ty).name()+"' is given.");
			}
			*/
			
			template<typename K,typename V,typename First>
auto get_first_match(const std::map<K,V>& mp,First f)->typename std::map<K,V>::const_iterator {
	return mp.find(f);
}

template<typename K,typename V,typename First,typename Second,typename... Rest>
auto get_first_match(const std::map<K,V>& mp,First f,Second s,Rest... rest)->typename std::map<K,V>::const_iterator {
	auto it=get_first_match(mp,f);
	if(it!=mp.end()){
		return it;
	}else{
		return get_first_match(mp,s,rest...);
	}

}

void init_visualizer(int* argcp, char** argv) {
    glutInit(argcp, argv);
    glutInitWindowPosition(0, 0);
    glutInitWindowSize(800, 600);
    initialized = true;

    glViewport(0, 0, 800, 600);
    glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45.0, float(800) / float(600), 0.1, 100.0);
        glMatrixMode(GL_MODELVIEW);
        OSMesaCreateContext(OSMESA_BGRA, 0);
}

static void polarview(void)
{
    glTranslatef(0.0, 0.0, -4*50*0.6);
    glRotatef(-0, 0.0, 0.0, 1.0);
    glRotatef(-0, 1.0, 0.0, 0.0);
    glRotatef(-175, 0.0, 1.0, 0.0);
}

static void initLighting(void)
{
    float  diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    float  specular[] = { 0.8, 0.8, 0.8, 1.0 };
    float  ambient[] = { 0.1, 0.1, 0.1, 1.0 };

    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);     /*gl_dif(kakusannkou): */
    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);   /*gl_sp(kyoumennkou):(1,1,1,1)*/
    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);    /*gl_am(kannkyoukou):(0,0,0,1)*/
    glEnable(GL_LIGHT0);
}

void visualize(const VisParams& vp) {
    initLighting();
    //float diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    float specular[] = { 0.3, 0.3, 0.3, 1.0 };
    float ambient[] = { 0.3, 0.3, 0.3, 1.0 };
    float light[] = { 1.0, 1.0, 5.0, 0.0 };
    if (!initialized) {
        throw std::logic_error("Visualizer not initialized");
    }
    static auto buf = std::vector<unsigned char>(800 * 600 * 4);
    static auto pngbuf = std::vector<unsigned char>();
    glutCreateWindow("PogChamp");
    glFlush();
    //polarview();
    for (int i = 0; i < 10; i++) {
        //test
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       // glClearColor(i*0.001, i*0.002, i*0.001, 1);
        glClearColor(0,0,0,1);
        
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
        glPushMatrix();
        glLightfv(GL_LIGHT0, GL_POSITION, light);
        float diffuse[] = { 1.0,0,0,1.0 };
        glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);      /*zennmenn kakusannkou*/
        glMaterialfv(GL_FRONT, GL_SPECULAR, specular);    /*kyoumennkolu*/
        glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);      /*kannkyoukou */
        glMaterialf(GL_FRONT, GL_SHININESS, 128.0);        /*shin:kyoumennkou sisuu*/

        glTranslatef(0, i*0.001, 0);
        glutSolidSphere(1, 100, 100);
        glTranslatef(0, -i*0.001, 0);
        gluLookAt(0.0, 0.0, -10.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
        glDisable(GL_LIGHTING);

        glDisable(GL_DEPTH_TEST);
        glPopMatrix();
        
        //glutSwapBuffers();
        glFlush();
        glReadPixels(0, 0, 800, 600, GL_RGBA, GL_UNSIGNED_BYTE, &buf[0]);
        lodepng::encode(std::to_string(i*10) + "ff.png", buf, 800, 600);
        
            /*
        if () {
           
            throw std::logic_error("Failed to convert buffer into png.");
        }
        
        lodepng::save_file(pngbuf, );
        */
    }
}


/*

void CellManager::load(const std::string& path,OnCellLoad on,void* udata) {
    auto&cman = *this;
    /*
    ファイル読み込み試行
    */
    std::ifstream dstrm(path);

    if (!dstrm) {
        throw std::runtime_error("Failed to load the cell data file:"_s + path);
    }

    //using namespace cont;


    /*
    読み込み用一時変数
    */
    CELL_STATE state = UNUSED;
    std::string line;
    int div_times = 0, touch = 0, pair_cell_id = 0, stem_orig_id = 0;
    double rad, ageb, agek, x, y, z, fat, spr_len, ex_fat, ca2p_avg, ca2p;

    /*
    細胞のインデックスのカウント
    (1行に1細胞あるので、1行読み込むごとにインクリメントする)
    */
    int id_count = 0;

    /*
    ペアを一時的に保存するvector

    ペアを持つ細胞を初めて見つけたとき、そのペアのインデックスは必ず自分より後なのでまだ生成されていない。
    そのため、ペアを持つ細胞があれば、自分のインデックスをキーとして一時的に入れておき、そのペアにたどり着いたときに互いのオブジェクトに登録する。
    */
    tmp_pair.resize(pm->MEMB_NUM_X*pm->MEMB_NUM_Y + 100000, nullptr);
    //std::fill(tmp_pair.begin(), tmp_pair.end(), nullptr);

    unsigned int phase = 0;
    int nmemb = 0;
    int nder = 0;

    while (std::getline(dstrm, line)) {

        sscanf(line.c_str(), "%*d %" SCNuFAST8 " %lf %lf %lf %lf %lf %lf %lf %lf %d %lf %lf %d %lf %d %d",
            (uint_fast8_t*)&state, &rad, &ageb, &agek, &ca2p, &x, &y, &z, &ca2p_avg, &div_times, &ex_fat, &fat, &touch, &spr_len, &pair_cell_id, &stem_orig_id);

        /*
        BLANKにたどり着いたら終了
        */
        if (state == BLANK)break;

        /*
        validation
        */
        if (pm->SYSTEM == BASAL && (state == ALIVE || state == DEAD || state == AIR)) {

            throw std::runtime_error(" input date must not contain ALIVE or DEAD in case of BASAL\n");
        }
        if (state == DER && rad != pm->R_der) {
            throw std::runtime_error("radii of DER not consistent with param.h\n");
            
        }
        if (state == MEMB && rad != pm->R_memb) {
            throw std::runtime_error("radii of DER not consistent with param.h\n");
        }
        if (phase == 0 && state != MEMB) {
            if (state != DER) {
                throw std::runtime_error("Wrong cell order:The next block of MEMB must be DER.");
            }
            phase++;
        }

        if (phase == 1 && state != DER) {
            phase++;
        }
        if (phase > 0 && state == MEMB) {
            throw std::runtime_error("Wrong cell order:A MEMB data is found out of MEMB block.");
        }
        if (phase > 1 && state == DER) {
            throw std::runtime_error("Wrong cell order:A DER data is found out of DER block.");
        }

        //if (state == FIX)printf("FIX\n");

        if (state == MEMB)nmemb++;
        if (state == DER)nder++;
        CellTempStruct cts;
        cts.ageb = ageb; cts.agek = agek; cts.ca2p = ca2p; cts.ca2p_avg = ca2p_avg;
        cts.div_times = div_times; cts.ex_fat = ex_fat; cts.fat = fat;
        cts.pair_cell_id = pair_cell_id; cts.rad = rad; cts.spr_len = spr_len;
        cts.state = state; cts.stem_orig_id = stem_orig_id; cts.touch = touch;
        cts.x = x; cts.y = y; cts.z = z; cts.id_count = id_count;
        on(cman, cts,udata);

        //std::cout << "Phase " << phase << "  Cell loaded:" << id_count++ << std::endl;
        id_count++;

    }
    cman.nmemb = nmemb;
#ifdef TRI_MEMB
    assert(nmemb == (NMX*NMY_tri));
    assert(NMY_tri % 2 == 0);
#endif
    cman.nder = nder;
}
*/